A journey into cracking RSA moduli with a common GCD

November, 2017

It's about two years ago that I played with <a href="https://github.com/DutchGraa/LazyfactPython">some code</a> for factoring small RSA moduli. About a month ago I was checking if it's possible to crack moduli in bulk. Can you collect a million of them, and crack them a million times as fast? It can speed up the process, but it doesn't really help. Normal RSA keys are so large that even with a big bunch of them, normal factoring algorithms don't 'get lucky'.

Searching bulk-cracking attacks brought me to <a href="http://www.loyalty.org/~schoen/rsa/">this page</a> with a great explanation on cracking RSA moduli that share a common GCD. To put it short: an RSA modulus is a multiple of two primes: p and q. If two moduli share a common factor (p or q), you can find this value extremely fast, because we have an efficient algorithm for finding the GCD of two numbers.

One of the best resources on this topic is the paper <a href="https://factorable.net/weakkeys12.extended.pdf">Mining Your Ps and Qs</a>. Not only does it explain the attack in great detail, it also shows amazing results of successful large-scale cracking attempts. A summary of the results can be found on their website, which also hosts the <a href="https://factorable.net/resources.html">source code</a> for their tool fastgcd, that can be used to find GCD pairs really fast. However, their websites states: "We have not released our code for distributed scanning or key collection". I wanted to make my own tool to mine moduli, and check if this attack still works in 2017.

The first few days I spent creating some tool using Python, with Queue for threading, sqlite for a database, normal threading for mutex locks, OpenSSL with Crypto.Util for parsing certificates and started scanning some <a href="http://docs.aws.amazon.com/general/latest/gr/aws-ip-ranges.html">AWS</a> and <a href="http://www.nirsoft.net/countryip/nl.html">Dutch</a> IP ranges. It was just awful. I used special scripts to create backups, export stuff from the database and parse results. The only useful part of it is <a href="https://gist.github.com/DutchGraa/ddb16e25bfbd48db014c8f8403319889">this code snippet</a> to retrieve a modulus from a server.

After some days painfully running scans I noticed that I really just created a crappy portscanner. So I looked over at nmap. As it turns out, nmap parses TLS certificates with the function <a href="https://nmap.org/nsedoc/lib/nmap.html#get_ssl_certificate">get_ssl_certificate</a>, and for RSA certificates <i>"it will also have an exponent member, containing the public exponent as a bignum."</i>. That's way better. I forked nmap and <a href="https://github.com/DutchGraa/nmap/commit/a798087b25e1e811eb36871f36bb6e535cb4e3a9">changed</a> the source code to return the modulus instead of the exponent, with a <a href="https://github.com/DutchGraa/nmap/commit/efd0898952385d28ad1f80f557126dd90f9d8d54">small script</a> to show the modulus. Now I can do nmap scans and just parse the results like a sane person.

After some more days running scans I retrieved about 250k moduli, and fastgcd found that 6 of them were vulnerable! After checking out the devices, all 6 seem to be Juniper Netscreen VPN firewalls. These devices contained a <a href="https://www.schneier.com/blog/archives/2016/04/details_about_j.html">known backdoor</a> that allowed for the decryption of VPN traffic. I think it's interesting to see that these properties are also detectable from their generated TLS certificates. Anyway, I showed these results to some co-workers, and one informed me that all certificates in public IPv4 address space can be downloaded from the <a href="https://www.censys.io/data">Censys Data Collection</a>!

After downloading some huge certificate files from Censys, I started extracting, sorting and factoring moduli. I used fastgcd on blocks of millions at a time, because the tool requires a lot of memory. By the way, <a href="https://www.researchgate.net/publication/280136262_Bulk_GCD_Computation_Using_a_GPU_to_Break_Weak_RSA_Keys">this cool paper</a> talks about a tool to utilize the GPU for performing this task at high speed. I spent some time finding a bunch of vulnerable moduli, mainly from Fritz!Box's for some reason, and it got boring. I thought about creating a tool to test new moduli against all the certificates from Censys, but this tool <a href="https://cryptosense.com/an-online-rsa-key-tester/">already exists</a>.

To sum it up, I spent two resourceful weeks re-inventing wheels. Some devices have trouble creating proper random numbers, and this introduces cryptographic flaws. The internet is hard at work to rub it in their faces. 